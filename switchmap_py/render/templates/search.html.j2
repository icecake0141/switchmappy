<!--
Copyright 2025 SwitchMapy Contributors
SPDX-License-Identifier: Apache-2.0

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

This file was created or modified with the assistance of an AI (Large Language Model).
Review required for correctness, security, and licensing.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Search - SwitchMap</title>
  <link rel="stylesheet" href="/switchmap.css" />
</head>
<body>
  <header>
    <h1>Search</h1>
  </header>
  <input id="query" type="text" placeholder="Search by switch, port, status, VLAN, neighbor, IP, MAC, host" />
  <div>
    <label for="typeFilter">Type:</label>
    <select id="typeFilter">
      <option value="">All</option>
      <option value="port">Port</option>
      <option value="mac">MAC</option>
    </select>
    <label for="statusFilter">Status:</label>
    <select id="statusFilter">
      <option value="">All</option>
      <option value="up">up</option>
      <option value="down">down</option>
    </select>
    <label for="vlanFilter">VLAN:</label>
    <input id="vlanFilter" type="text" placeholder="e.g. 10" />
    <label for="neighborFilter">Neighbor:</label>
    <input id="neighborFilter" type="text" placeholder="e.g. dist-sw1" />
    <label for="inErrFilter">In Err >=</label>
    <input id="inErrFilter" type="number" min="0" step="1" placeholder="0" />
    <label for="outErrFilter">Out Err >=</label>
    <input id="outErrFilter" type="number" min="0" step="1" placeholder="0" />
    <label for="sortBy">Sort:</label>
    <select id="sortBy">
      <option value="switch-port">Switch/Port</option>
      <option value="vlan">VLAN</option>
      <option value="neighbor">Neighbor</option>
      <option value="in-errors">In Err</option>
      <option value="out-errors">Out Err</option>
      <option value="type">Type</option>
    </select>
    <button id="resetFilters" type="button">Reset</button>
  </div>
  <p id="resultCount">0 results</p>
  <p id="emptyState" hidden>No matching entries.</p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Switch</th>
        <th>Port</th>
        <th>Status</th>
        <th>VLAN</th>
        <th>Neighbor</th>
        <th>In Err</th>
        <th>Out Err</th>
        <th>MAC</th>
        <th>IP</th>
        <th>Hostname</th>
      </tr>
    </thead>
    <tbody id="results"></tbody>
  </table>
  <script>
    async function loadIndex() {
      const response = await fetch('/search/index.json');
      return response.json();
    }

    function match(entry, query) {
      const haystack = [
        entry.type,
        entry.switch,
        entry.port,
        entry.status,
        entry.vlan,
        entry.neighbor,
        entry.input_errors,
        entry.output_errors,
        entry.mac,
        entry.ip,
        entry.hostname,
      ]
        .filter(Boolean)
        .join(' ')
        .toLowerCase();
      return haystack.includes(query);
    }

    function applyFilters(entries) {
      const query = document.getElementById('query').value.toLowerCase().trim();
      const type = document.getElementById('typeFilter').value;
      const status = document.getElementById('statusFilter').value;
      const vlan = document.getElementById('vlanFilter').value.toLowerCase().trim();
      const neighbor = document.getElementById('neighborFilter').value.toLowerCase().trim();
      const inErr = document.getElementById('inErrFilter').value.trim();
      const outErr = document.getElementById('outErrFilter').value.trim();
      const minInErr = inErr ? Number.parseInt(inErr, 10) : null;
      const minOutErr = outErr ? Number.parseInt(outErr, 10) : null;
      return entries.filter((entry) => {
        if (type && entry.type !== type) {
          return false;
        }
        if (status && entry.status !== status) {
          return false;
        }
        if (vlan && !(entry.vlan || '').toLowerCase().includes(vlan)) {
          return false;
        }
        if (neighbor && !(entry.neighbor || '').toLowerCase().includes(neighbor)) {
          return false;
        }
        if (minInErr !== null && Number.isFinite(minInErr) && Number(entry.input_errors || 0) < minInErr) {
          return false;
        }
        if (minOutErr !== null && Number.isFinite(minOutErr) && Number(entry.output_errors || 0) < minOutErr) {
          return false;
        }
        return !query || match(entry, query);
      });
    }

    function sortEntries(entries) {
      const sortBy = document.getElementById('sortBy').value;
      const sorted = [...entries];
      if (sortBy === 'vlan') {
        sorted.sort((a, b) => (a.vlan || '').localeCompare(b.vlan || ''));
      } else if (sortBy === 'neighbor') {
        sorted.sort((a, b) => (a.neighbor || '').localeCompare(b.neighbor || ''));
      } else if (sortBy === 'in-errors') {
        sorted.sort((a, b) => Number(b.input_errors || 0) - Number(a.input_errors || 0));
      } else if (sortBy === 'out-errors') {
        sorted.sort((a, b) => Number(b.output_errors || 0) - Number(a.output_errors || 0));
      } else if (sortBy === 'type') {
        sorted.sort((a, b) => (a.type || '').localeCompare(b.type || ''));
      } else {
        sorted.sort((a, b) => {
          const left = `${a.switch || ''}/${a.port || ''}`;
          const right = `${b.switch || ''}/${b.port || ''}`;
          return left.localeCompare(right);
        });
      }
      return sorted;
    }

    function macEntries(index) {
      return (index.maclist || []).map((entry) => ({
        type: 'mac',
        switch: entry.switch ?? '',
        port: entry.port ?? '',
        status: '',
        vlan: '',
        neighbor: '',
        input_errors: '',
        output_errors: '',
        mac: entry.mac ?? '',
        ip: entry.ip ?? '',
        hostname: entry.hostname ?? '',
        target_url: (entry.switch && entry.port)
          ? `/switches/${entry.switch}.html#port-${entry.port.replaceAll('/', '-').replaceAll(' ', '-').replaceAll('.', '-')}`
          : '',
      }));
    }

    function switchPortEntries(index) {
      const rows = [];
      for (const sw of index.switches || []) {
        for (const port of sw.ports || []) {
          rows.push({
            type: 'port',
            switch: sw.name ?? '',
            port: port.name ?? '',
            status: port.oper_status ?? '',
            vlan: port.vlan ?? '',
            neighbor: (port.neighbors || []).map((n) => n.device || '').filter(Boolean).join(', '),
            input_errors: port.input_errors ?? 0,
            output_errors: port.output_errors ?? 0,
            mac: (port.macs || []).join(', '),
            ip: '',
            hostname: '',
            target_url: (sw.name && port.name)
              ? `/switches/${sw.name}.html#port-${port.name.replaceAll('/', '-').replaceAll(' ', '-').replaceAll('.', '-')}`
              : '',
          });
        }
      }
      return rows;
    }

    function buildEntries(index) {
      return macEntries(index).concat(switchPortEntries(index));
    }

    function render(entries) {
      const tbody = document.getElementById('results');
      tbody.replaceChildren();
      document.getElementById('emptyState').hidden = entries.length > 0;
      document.getElementById('resultCount').textContent = `${entries.length} results`;
      for (const entry of entries) {
        const row = document.createElement('tr');
        const values = [
          entry.type ?? '',
          entry.switch ?? '',
          entry.port ?? '',
          entry.status ?? '',
          entry.vlan ?? '',
          entry.neighbor ?? '',
          entry.input_errors ?? '',
          entry.output_errors ?? '',
          entry.mac ?? '',
          entry.ip ?? '',
          entry.hostname ?? '',
        ];
        for (const value of values) {
          const cell = document.createElement('td');
          cell.textContent = value;
          row.appendChild(cell);
        }
        if (entry.target_url) {
          row.style.cursor = 'pointer';
          row.addEventListener('click', () => {
            window.location.href = entry.target_url;
          });
        }
        tbody.appendChild(row);
      }
    }

    function readFiltersFromUrl() {
      const params = new URLSearchParams(window.location.search);
      document.getElementById('query').value = params.get('q') || '';
      document.getElementById('typeFilter').value = params.get('type') || '';
      document.getElementById('statusFilter').value = params.get('status') || '';
      document.getElementById('vlanFilter').value = params.get('vlan') || '';
      document.getElementById('neighborFilter').value = params.get('neighbor') || '';
      document.getElementById('inErrFilter').value = params.get('inErr') || '';
      document.getElementById('outErrFilter').value = params.get('outErr') || '';
      document.getElementById('sortBy').value = params.get('sort') || 'switch-port';
    }

    function writeFiltersToUrl() {
      const params = new URLSearchParams();
      const query = document.getElementById('query').value.trim();
      const type = document.getElementById('typeFilter').value;
      const status = document.getElementById('statusFilter').value;
      const vlan = document.getElementById('vlanFilter').value.trim();
      const neighbor = document.getElementById('neighborFilter').value.trim();
      const inErr = document.getElementById('inErrFilter').value.trim();
      const outErr = document.getElementById('outErrFilter').value.trim();
      const sort = document.getElementById('sortBy').value;
      if (query) params.set('q', query);
      if (type) params.set('type', type);
      if (status) params.set('status', status);
      if (vlan) params.set('vlan', vlan);
      if (neighbor) params.set('neighbor', neighbor);
      if (inErr) params.set('inErr', inErr);
      if (outErr) params.set('outErr', outErr);
      if (sort && sort !== 'switch-port') params.set('sort', sort);
      const queryString = params.toString();
      const next = queryString ? `?${queryString}` : window.location.pathname;
      window.history.replaceState({}, '', next);
    }

    async function init() {
      const index = await loadIndex();
      const entries = buildEntries(index);
      readFiltersFromUrl();
      const refresh = () => {
        render(sortEntries(applyFilters(entries)));
        writeFiltersToUrl();
      };
      const reset = () => {
        document.getElementById('query').value = '';
        document.getElementById('typeFilter').value = '';
        document.getElementById('statusFilter').value = '';
        document.getElementById('vlanFilter').value = '';
        document.getElementById('neighborFilter').value = '';
        document.getElementById('inErrFilter').value = '';
        document.getElementById('outErrFilter').value = '';
        document.getElementById('sortBy').value = 'switch-port';
        refresh();
      };
      refresh();
      document.getElementById('query').addEventListener('input', refresh);
      document.getElementById('typeFilter').addEventListener('change', refresh);
      document.getElementById('statusFilter').addEventListener('change', refresh);
      document.getElementById('vlanFilter').addEventListener('input', refresh);
      document.getElementById('neighborFilter').addEventListener('input', refresh);
      document.getElementById('inErrFilter').addEventListener('input', refresh);
      document.getElementById('outErrFilter').addEventListener('input', refresh);
      document.getElementById('sortBy').addEventListener('change', refresh);
      document.getElementById('resetFilters').addEventListener('click', reset);
    }

    init();
  </script>
</body>
</html>
